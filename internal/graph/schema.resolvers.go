package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"EffectiveMobile/entity"
	"EffectiveMobile/internal/graph/model"
	"context"
	"fmt"
	"strconv"

	"github.com/sirupsen/logrus"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*string, error) {
	tmpUser := entity.User{
		Name:    input.Name,
		Surname: input.Surname,
	}

	if input.Patronymic != nil {
		tmpUser.Patronymic = *input.Patronymic
	}

	if input.Age != nil {
		tmpUser.Age = *input.Age
	}

	if input.Gender != nil {
		tmpUser.Gender = *input.Gender
	}

	if input.Nationality != nil {
		tmpUser.Nationality = *input.Nationality
	}

	tmpId, err := r.repo.Create(tmpUser)
	if err != nil {
		logrus.Error(err.Error())
		return nil, err
	}

	id := strconv.Itoa(tmpId)

	return &id, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*string, error) {
	tmpId, err := strconv.Atoi(id)
	if err != nil {
		logrus.Error(err.Error())
		return nil, err
	}

	err = r.repo.Delete(tmpId)
	if err != nil {
		logrus.Error(err.Error())
		return nil, err
	}

	return &id, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, minAge *int, maxAge *int, age *int, page *int, perPage *int, gender *string) ([]*model.User, error) {
	var (
		defaultMinAge  = 0
		defaultMaxAge  = 100
		defaultPage    = 1
		defaultPerPage = 10
	)

	if minAge == nil {
		minAge = &defaultMinAge
	}

	if maxAge == nil {
		maxAge = &defaultMaxAge
	}

	if age != nil {
		minAge = age
		maxAge = age
	}

	if page == nil {
		page = &defaultPage
	}

	if perPage == nil {
		perPage = &defaultPerPage
	}

	offset := (*page - 1) * *perPage
	query := fmt.Sprintf("SELECT * FROM users WHERE age >= %d AND age <= %d", *minAge, *maxAge)

	if gender != nil {
		query += fmt.Sprintf("AND gender = %s", *gender)
	}

	query += fmt.Sprintf(" LIMIT %d OFFSET %d", *perPage, offset)

	tmpUsers, err := r.repo.GetAll(query)
	if err != nil {
		logrus.Error(err.Error())
		return nil, err
	}

	var users []*model.User

	for _, user := range tmpUsers {
		tmpUser := model.User{
			ID:          strconv.Itoa(user.Id),
			Name:        user.Name,
			Surname:     user.Surname,
			Patronymic:  &user.Patronymic,
			Age:         &user.Age,
			Gender:      &user.Gender,
			Nationality: &user.Nationality,
		}
		users = append(users, &tmpUser)
	}

	return users, err
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	var user model.User

	idInd, err := strconv.Atoi(id)
	if err != nil {
		logrus.Error(err.Error())
		return nil, err
	}

	tmpUser, err := r.repo.GetById(idInd)
	if err != nil {
		logrus.Error(err.Error())
		return nil, err
	}

	user.ID = strconv.Itoa(tmpUser.Id)
	user.Name = tmpUser.Name
	user.Surname = tmpUser.Surname
	user.Patronymic = &tmpUser.Patronymic
	user.Age = &tmpUser.Age
	user.Gender = &tmpUser.Gender
	user.Nationality = &tmpUser.Nationality

	return &user, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
